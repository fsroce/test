<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas Chart Performance Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .controls {
      margin-bottom: 20px;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      cursor: pointer;
    }
    #performance {
      background: #f0f0f0;
      padding: 10px;
      margin: 20px 0;
      border-radius: 5px;
    }
    #chart-container {
      border: 1px solid #ccc;
      padding: 10px;
      width: 800px;
      height: 400px;
    }
    #canvas {
      border: none;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Canvas Chart Performance Test</h1>

  <div class="controls">
    <button onclick="createLineChart(100)">100ç‚¹æŠ˜çº¿å›¾</button>
    <button onclick="createLineChart(500)">500ç‚¹æŠ˜çº¿å›¾</button>
    <button onclick="createLineChart(1000)">1000ç‚¹æŠ˜çº¿å›¾</button>
    <button onclick="createBarChart(50)">50æŸ±çŠ¶å›¾</button>
    <button onclick="createBarChart(100)">100æŸ±çŠ¶å›¾</button>
    <button onclick="createBarChart(200)">200æŸ±çŠ¶å›¾</button>
    <button onclick="startRealTimeChart()">å®æ—¶æ•°æ®å›¾</button>
    <button onclick="stopRealTime()">åœæ­¢</button>
    <button onclick="clearChart()">æ¸…ç©º</button>
  </div>

  <div id="performance">
    <strong>Performance Info:</strong>
    <div id="stats"></div>
  </div>

  <div style="background: #f9f9f9; padding: 15px; margin: 20px 0; border-radius: 5px; font-size: 14px;">
    <h3 style="margin-top: 0;">ğŸ“Š æ€§èƒ½æŒ‡æ ‡è¯´æ˜</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
      <div>
        <h4>ğŸ“ˆ æ—¶é—´æŒ‡æ ‡</h4>
        <ul style="margin: 0; padding-left: 20px;">
          <li><strong>æ€»æ—¶é—´</strong>: performance.now() å®Œæ•´æµ‹é‡</li>
          <li><strong>åˆ›å»ºæ—¶é—´</strong>: Canvasç»˜åˆ¶å‘½ä»¤è€—æ—¶</li>
          <li><strong>æ›´æ–°æ—¶é—´</strong>: å®æ—¶å›¾è¡¨å•å¸§é‡ç»˜è€—æ—¶</li>
          <li><strong>ç‚¹å‡»æ£€æµ‹</strong>: åæ ‡è®¡ç®—å“åº”é€Ÿåº¦</li>
        </ul>
      </div>
      <div>
        <h4>ğŸ’¾ å†…å­˜ä¼°ç®—</h4>
        <ul style="margin: 0; padding-left: 20px;">
          <li><strong>æ•°æ®ç‚¹</strong>: æ¯ä¸ªçº¦50å­—èŠ‚</li>
          <li><strong>çº¿æ®µ</strong>: æ¯ä¸ªçº¦30å­—èŠ‚</li>
          <li><strong>æŸ±çŠ¶å›¾</strong>: æ¯ä¸ªçº¦30å­—èŠ‚</li>
          <li>ä¸»è¦å­˜å‚¨åæ ‡å’Œé¢œè‰²æ•°æ®</li>
        </ul>
      </div>
    </div>
    <div style="margin-top: 15px;">
      <h4>ğŸ¯ æ€§èƒ½è¯„çº§æ ‡å‡†</h4>
      <div style="display: flex; gap: 15px; flex-wrap: wrap;">
        <span>ğŸŸ¢ ä¼˜ç§€: &lt;0.05ms/å…ƒç´ </span>
        <span>ğŸŸ¡ è‰¯å¥½: 0.05-0.2ms/å…ƒç´ </span>
        <span>ğŸŸ  ä¸€èˆ¬: 0.2-0.5ms/å…ƒç´ </span>
        <span>ğŸ”´ è¾ƒå·®: &gt;0.5ms/å…ƒç´ </span>
      </div>
    </div>
    <div style="margin-top: 10px; padding: 10px; background: #e8f5e8; border-radius: 3px;">
      <strong>ğŸ’¡ Canvasä¼˜åŠ¿:</strong> é«˜æ•ˆç»˜åˆ¶ã€å†…å­˜å›ºå®šã€é€‚åˆåŠ¨ç”»ã€æ— DOMå¼€é”€<br>
      <strong>âš ï¸ CanvasåŠ£åŠ¿:</strong> æ‰‹åŠ¨äº‹ä»¶å¤„ç†ã€æ— æµè§ˆå™¨ä¼˜åŒ–ã€å¤§ç”»å¸ƒå†…å­˜å ç”¨é«˜
    </div>
  </div>

  <div id="chart-container">
    <canvas id="canvas" width="780" height="380"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stats = document.getElementById('stats');
    let realTimeInterval;
    let realTimeData = [];
    let chartData = [];

    function clearChart() {
      const startTime = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      chartData = [];
      drawAxes();
      const endTime = performance.now();

      stats.innerHTML = `Cleared in ${(endTime - startTime).toFixed(2)}ms`;
    }

    function drawAxes() {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      // X axis
      ctx.moveTo(0, canvas.height - 1);
      ctx.lineTo(canvas.width, canvas.height - 1);
      // Y axis
      ctx.moveTo(0, 0);
      ctx.lineTo(0, canvas.height);
      ctx.stroke();
    }

    function createLineChart(pointCount) {
      const startTime = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawAxes();

      const width = canvas.width;
      const height = canvas.height;
      const points = [];
      chartData = [];

      // Generate data points
      for (let i = 0; i < pointCount; i++) {
        const x = (i / (pointCount - 1)) * width;
        const y = height - (Math.random() * 0.7 + 0.1) * height;
        points.push({ x, y });
        chartData.push({ x, y, id: i });
      }

      const createStart = performance.now();

      // Draw line
      ctx.strokeStyle = '#4ecdc4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();

      // Draw points (match DOM 4px size)
      ctx.fillStyle = '#ff6b6b';
      points.forEach((point, i) => {
        ctx.beginPath();
        ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
        ctx.fill();

        // Add point number for small datasets
        if (pointCount <= 100) {
          ctx.fillStyle = 'white';
          ctx.font = '8px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(i.toString(), point.x, point.y + 2);
          ctx.fillStyle = '#ff6b6b';
        }
      });

      const endTime = performance.now();
      const totalTime = endTime - startTime;
      const createTime = endTime - createStart;

      updateStats('CanvasæŠ˜çº¿å›¾', pointCount, totalTime, createTime, pointCount * 50);
    }

    function createBarChart(barCount) {
      const startTime = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawAxes();

      const width = canvas.width;
      const height = canvas.height;
      const barWidth = 8; // Match DOM bar width
      chartData = [];

      const createStart = performance.now();

      for (let i = 0; i < barCount; i++) {
        const barHeight = (Math.random() * 0.8 + 0.1) * height;
        const x = i * (barWidth + 2) + 1; // Match DOM spacing
        const y = height - barHeight;

        // Store data for click detection
        chartData.push({
          x: x,
          y: y,
          width: barWidth,
          height: barHeight,
          id: i
        });

        // Create gradient
        const gradient = ctx.createLinearGradient(0, y, 0, height);
        gradient.addColorStop(0, '#4ecdc4');
        gradient.addColorStop(1, '#ff6b6b');

        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth, barHeight);

        // Add bar number for small datasets
        if (barCount <= 50) {
          ctx.fillStyle = 'white';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(i.toString(), x + barWidth/2, y + barHeight/2);
        }
      }

      const endTime = performance.now();
      const totalTime = endTime - startTime;
      const createTime = endTime - createStart;

      updateStats('CanvasæŸ±çŠ¶å›¾', barCount, totalTime, createTime, barCount * 30);
    }

    function startRealTimeChart() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawAxes();
      realTimeData = [];
      let frameCount = 0;
      const maxPoints = 100;

      realTimeInterval = setInterval(() => {
        const updateStart = performance.now();

        // Add new data point
        const newValue = Math.random() * 300 + 50;
        realTimeData.push(newValue);

        if (realTimeData.length > maxPoints) {
          realTimeData.shift();
        }

        // Clear and redraw everything
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawAxes();

        // Draw line
        if (realTimeData.length > 1) {
          ctx.strokeStyle = `hsl(${frameCount % 360}, 70%, 60%)`;
          ctx.lineWidth = 2;
          ctx.beginPath();

          const pointSpacing = canvas.width / maxPoints;
          realTimeData.forEach((value, i) => {
            const x = i * pointSpacing;
            const y = canvas.height - value;

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          ctx.stroke();

          // Draw points
          ctx.fillStyle = `hsl(${frameCount % 360}, 70%, 60%)`;
          realTimeData.forEach((value, i) => {
            const x = i * pointSpacing;
            const y = canvas.height - value;

            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        const updateEnd = performance.now();
        const updateTime = updateEnd - updateStart;

        frameCount++;
        if (frameCount % 10 === 0) {
          stats.innerHTML = `å®æ—¶å›¾è¡¨æ›´æ–° - ç¬¬${frameCount}å¸§ (æ›´æ–°: ${updateTime.toFixed(2)}ms, æ•°æ®ç‚¹: ${realTimeData.length})`;
        }
      }, 50); // 20 FPS
    }

    function stopRealTime() {
      if (realTimeInterval) {
        clearInterval(realTimeInterval);
        realTimeInterval = null;
      }
    }

    function updateStats(type, count, totalTime, createTime, memoryUsage) {
      stats.innerHTML = `
        <div>å›¾è¡¨ç±»å‹: ${type}</div>
        <div>æ•°æ®ç‚¹æ•°: ${count}</div>
        <div>æ€»æ—¶é—´: ${totalTime.toFixed(2)}ms</div>
        <div>åˆ›å»ºæ—¶é—´: ${createTime.toFixed(2)}ms</div>
        <div>é¢„ä¼°å†…å­˜: ${(memoryUsage / 1024).toFixed(2)}KB</div>
        <div>æ€§èƒ½è¯„çº§: ${getPerformanceRating(count, totalTime)}</div>
      `;
    }

    function getPerformanceRating(count, time) {
      const ratio = time / count;
      if (ratio < 0.05) return 'ğŸŸ¢ ä¼˜ç§€';
      if (ratio < 0.2) return 'ğŸŸ¡ è‰¯å¥½';
      if (ratio < 0.5) return 'ğŸŸ  ä¸€èˆ¬';
      return 'ğŸ”´ è¾ƒå·®';
    }

    // Click detection for canvas
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      const startTime = performance.now();

      let clickedItem = null;

      // Check if clicked on chart data
      for (let i = 0; i < chartData.length; i++) {
        const item = chartData[i];

        if (item.width && item.height) {
          // Bar chart detection
          if (clickX >= item.x && clickX <= item.x + item.width &&
              clickY >= item.y && clickY <= item.y + item.height) {
            clickedItem = item;
            break;
          }
        } else {
          // Line chart point detection (within 10px radius)
          const distance = Math.sqrt(
            Math.pow(clickX - item.x, 2) + Math.pow(clickY - item.y, 2)
          );
          if (distance <= 10) {
            clickedItem = item;
            break;
          }
        }
      }

      const endTime = performance.now();
      const detectTime = endTime - startTime;

      if (clickedItem) {
        console.log(`Clicked Canvas Chart Item #${clickedItem.id}`);
        stats.innerHTML += `<div>ç‚¹å‡»é¡¹ç›® #${clickedItem.id} (æ£€æµ‹: ${detectTime.toFixed(2)}ms)</div>`;
      } else {
        console.log(`Clicked empty area`);
        stats.innerHTML += `<div>ç‚¹å‡»ç©ºç™½åŒºåŸŸ (æ£€æµ‹: ${detectTime.toFixed(2)}ms)</div>`;
      }
    });

    // Initialize with axes
    drawAxes();
  </script>
</body>
</html>